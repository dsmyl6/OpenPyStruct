# **OpenPyStruct**

**OpenPyStruct** is an open-source toolkit designed for machine learning-based structural optimization. Leveraging
**Physics-Informed Neural Networks (PINNs)**, **Transformer-Diffusion Modules**, and other state-of-the-art techniques,
the framework provides powerful tools for tackling **single and multi-load case optimization** problems with diverse
boundary and loading conditions.

## **Table of Contents**

- [**OpenPyStruct**](#openpystruct)
  - [**Table of Contents**](#table-of-contents)
  - [**Features**](#features)
  - [**Requirements**](#requirements)
  - [**BeamOpt Usage**](#beamopt-usage)
    - [**Overview**](#overview)
    - [**Key Features**](#key-features)
    - [**How to Use**](#how-to-use)
      - [1. Set Parameters](#1-set-parameters)
      - [2. Model Setup](#2-model-setup)
      - [3. Loss Calculation](#3-loss-calculation)
      - [4. Optimization Loop](#4-optimization-loop)
      - [5. Visualizing Results](#5-visualizing-results)
      - [6. Final Results](#6-final-results)
      - [Example Execution](#example-execution)
    - [**Physics-Informed Neural Network MultiCase**](#physics-informed-neural-network-multicase)
      - [**Overview**](#overview-1)
      - [**Key Features**](#key-features-1)
      - [**How to Use**](#how-to-use-1)
  - [**Contributor Guide**](#contributor-guide)
  - [**MIT License**](#mit-license)

---

## **Features**

- **Physics-Informed Neural Networks (PINNs):** Embeds structural mechanics into the learning process for highly
  accurate predictions.
- **Transformer-Diffusion Modules:** Incorporates advanced attention mechanisms and diffusion-based techniques for
  modeling complex structural behavior.
- **Feedforward Neural Networks (FNNs):** Provides scalable solutions for simpler structural optimization tasks.
- **Multi-Core and GPU-Accelerated Optimization:** Enables large-scale data generation and rapid computations.
- **OpenSeesPy Integration:** Facilitates physics-based finite element simulations.
- **Flexible Loss Functions and Parameter Design:** Supports user-defined constraints, objectives, and optimization
  goals.

---

## **Requirements**

Windows 10+ (this does not work on Mac)

To create a Conda environment with all dependencies, run:

```zsh
conda env create -f environment.yml
conda activate OpenPyStruct
```

---

## **BeamOpt Usage**

[Link to file in repo](./OpenPyStruct_BeamOpt.py)

### **Overview**

This script optimizes the **moment of inertia distribution** along a beam to minimize structural response (e.g.,
deflection, internal forces) while maintaining structural efficiency. The optimization iteratively adjusts the moment of
inertia of beam elements to reduce bending and shear energy losses.

### **Key Features**

- **OpenSeesPy-based** finite element analysis.
- **PyTorch-powered** gradient-based optimization.
- Simulates **beam behavior** under various loads (point forces, distributed loads).
- **Randomized placement** of roller supports and point loads for robustness.
- Optimizes **moment of inertia** to minimize structural energy loss.
- Implements **early stopping** for computational efficiency.
- **Visualization** of optimization progress and structural response.

### **How to Use**

Below is an explanation of how to use the code.

#### 1. Set Parameters

The code requires defining several parameters before running the optimization loop. These parameters control the beam's
properties, loads, and optimization settings. Below is an explanation of the key parameters:

- `E`: Young's Modulus (Pa)
- `nu`: Poisson's ratio
- `G`: Shear modulus (Pa)
- `A`: Cross-sectional area (m²)
- `L`: Length of the beam (m)
- `num_nodes`: Number of nodes in the beam
- `num_elements`: Number of beam elements (determined by `num_nodes`)
- `N_rollers`: Number of additional roller supports
- `M_forces`: Number of point forces applied
- `L_min`: Minimum distance between roller supports (m)
- `max_force`: Maximum point load applied to the beam (N)
- `uniform_udl`: Uniformly distributed load (N/m)
- `I_0`: Initial guess for the moments of inertia for each element

Optimization parameters include:

- `num_epochs`: Number of epochs to run the optimization
- `lr`: Learning rate for the optimizer
- `gamma`: Learning rate decay rate
- `alpha_moment`: Coefficient for the bending energy loss term
- `alpha_shear`: Coefficient for the shear energy loss term

#### 2. Model Setup

The model setup is handled by the `setup_model()` function. It uses the following inputs:

- `I_tensor`: Current values for the moments of inertia for each beam element.
- `node_positions`: The positions of nodes along the beam (generated by `np.linspace`).
- `roller_nodes`: List of nodes with roller supports.
- `force_nodes`: List of nodes where point forces are applied.
- `force_values`: Corresponding forces applied to each node.
- `A`, `E`, `uniform_udl`: The cross-sectional area, Young's Modulus, and uniform distributed load.

The model is built in OpenSees, defining the beam nodes, supports, elements, point loads, and the uniform load. It also
sets up the analysis parameters for static analysis.

#### 3. Loss Calculation

The `compute_combined_loss()` function computes the total loss, which is the sum of:

- The **primary loss**, which minimizes the sum of the moments of inertia across all elements.
- **Bending energy loss**, which is proportional to the square of the bending moments.
- **Shear energy loss**, which is proportional to the square of the shear forces.

These losses are used to guide the optimization process.

#### 4. Optimization Loop

The optimization loop iterates over `num_epochs`, optimizing the moments of inertia (`I_tensor`) using the Adam
optimizer. At each epoch, the following steps are performed:

1. The OpenSees model is wiped and rebuilt with updated `I_tensor`.
2. The model undergoes a static analysis.
3. The combined loss is computed.
4. Backpropagation is performed, and the optimizer updates the `I_tensor`.
5. A learning rate scheduler (`ExponentialLR`) adjusts the learning rate for smoother convergence.
6. The moments of inertia are clamped to ensure they remain positive.

The loop checks for convergence by monitoring the loss. If the loss does not improve for `patience` epochs, the
optimization is stopped early.

#### 5. Visualizing Results

After the optimization loop, the optimized moments of inertia (`I_values`) are used to generate the following plots:

- **Beam Element Cross-Sectional Heights**: Plots the beam's sections with varying thickness based on the optimized
  moments of inertia.
- **Shear Force Diagram**: Plots the shear forces along the length of the beam.
- **Bending Moment Diagram**: Plots the bending moments along the length of the beam.

These visualizations help analyze the beam's performance after optimization.

#### 6. Final Results

At the end of the optimization, the optimized moments of inertia are saved and can be used for further analysis or
design. The shear forces and bending moments are converted to kN and kN·m, respectively, for easier interpretation.

#### Example Execution

TBD

### **Physics-Informed Neural Network MultiCase**

#### **Overview**

to write

#### **Key Features**

to write

#### **How to Use**

to write

---

## **Contributor Guide**

To maintain consistency and improve code quality across the project, we recommend setting up pre-commit hooks and using
linting tools formatted with the provided config files. These tools will help ensure that your contributions adhere to
the established coding standards for both Python and markdown documentation.

The extensions required are specified in `.vscode\extensions.json` file

With the right conda environment activated, run:

```zsh
pre-commit install
```

---

## **MIT License**

Copyright (c) 2025 Danny Smyl

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
documentation files (the “Software”), to deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit
persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
